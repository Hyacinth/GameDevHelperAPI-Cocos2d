
#import "Physics_CollisionFiltering.h"

#pragma mark - Physics_CollisionFiltering

@implementation Physics_CollisionFiltering

-(id)init{
    self = [super init];
    if(self){
        
    }
    return self;
}

-(void) initPhysics
{
	
	CGSize s = [[CCDirector sharedDirector] winSize];
	
	b2Vec2 gravity;
	gravity.Set(0.0f, -10.0f);
	world = new b2World(gravity);
	
	
	// Do we want to let bodies sleep?
	world->SetAllowSleeping(true);
	
	world->SetContinuousPhysics(true);
		
	
	// Define the ground body.
	b2BodyDef groundBodyDef;
	groundBodyDef.position.Set(0, 0); // bottom-left corner
	
	// Call the body factory which allocates memory for the ground body
	// from a pool and creates the ground box shape (also from a pool).
	// The body is also added to the world.
    groundBody = world->CreateBody(&groundBodyDef);
	
	// Define the ground box shape.
	b2EdgeShape groundBox;
	
        
	// bottom
	
	groundBox.Set(b2Vec2(0,0), b2Vec2(s.width/PTM_RATIO,0));
	b2Fixture* fixture = groundBody->CreateFixture(&groundBox,0);
//    fixture->SetFilterData(filter);
    
	// top
	groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO));
    fixture = groundBody->CreateFixture(&groundBox,0);
//    fixture->SetFilterData(filter);
	
	// left
	groundBox.Set(b2Vec2(0,s.height/PTM_RATIO), b2Vec2(0,0));
	fixture = groundBody->CreateFixture(&groundBox,0);
//    fixture->SetFilterData(filter);
    
	// right
	groundBox.Set(b2Vec2(s.width/PTM_RATIO,s.height/PTM_RATIO), b2Vec2(s.width/PTM_RATIO,0));
	fixture = groundBody->CreateFixture(&groundBox,0);
//    fixture->SetFilterData(filter);
    
}


-(void)createMouseJointForTouchLocation:(CGPoint)point
{
    if(groundBody == NULL)
        return;
    
    b2Body* ourBody = NULL;

    b2Vec2 locationInWorld = GH_POINT_TO_METERS(point);

    
    for (b2Body* b = world->GetBodyList(); b; b = b->GetNext())
    {
        if(b != groundBody)
        {
            b2Fixture* stFix = b->GetFixtureList();
            while(stFix != 0){
                
                if(stFix->TestPoint(locationInWorld))
                {
                    ourBody = b;
                    break;//exit for loop
                }
                stFix = stFix->GetNext();
            }
        }
    }
    
    if(ourBody == NULL)
        return;
    
    
    
    b2MouseJointDef md;
    md.bodyA = groundBody;
    md.bodyB = ourBody;
    
    
    md.target = locationInWorld;
    md.collideConnected = true;
    md.maxForce = 1000.0f * ourBody->GetMass();
    ourBody->SetAwake(true);
    
    if(mouseJoint){
        world->DestroyJoint(mouseJoint);
        mouseJoint = NULL;
    }
    
    mouseJoint = (b2MouseJoint *)world->CreateJoint(&md);
}

-(void) setTargetOnMouseJoint:(CGPoint)point
{
    if(mouseJoint == 0)
        return;
    b2Vec2 locationWorld = b2Vec2(point.x/PTM_RATIO,
                                  point.y/PTM_RATIO);
    
    mouseJoint->SetTarget(locationWorld);
}

-(void)destroyMouseJoint{
    if(mouseJoint){
        world->DestroyJoint(mouseJoint);
        mouseJoint = NULL;
    }
}



-(void) update: (ccTime) dt
{
	//It is recommended that a fixed time step is used with Box2D for stability
	//of the simulation, however, we are using a variable time step here.
	//You need to make an informed choice, the following URL is useful
	//http://gafferongames.com/game-physics/fix-your-timestep/
	
	int32 velocityIterations = 8;
	int32 positionIterations = 1;
	
	// Instruct the world to perform a single step of simulation. It is
	// generally best to keep the time step and iterations fixed.
	world->Step(dt, velocityIterations, positionIterations);
}


-(NSString*)initTest{

//    CGSize s = [CCDirector sharedDirector].winSize;
    
    [self initPhysics];
    
    
    GHDebugDrawLayer* debugDraw = [GHDebugDrawLayer debugDrawLayerWithWorld:world];
    [self addChild:debugDraw z:1000];
    
#if 1
		// Use batch node. Faster
        //when using batches - load a batch node using the generated image
        batchNodeParent = [CCSpriteBatchNode batchNodeWithFile:@"RES_Physics_CollisionFiltering/physicsCollisionTestRobots_robots.png" capacity:100];
    
		[self addChild:batchNodeParent z:0];
#endif
        

    //load into the sprite frame cache the plist generated by SH
    [[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"RES_Physics_CollisionFiltering/physicsCollisionTestRobots_robots.plist"];

    //set the current world you want to use when creating bodies
    //in case you have multiple worlds just set the coresponding world before creating the sprites
    //CAREFULL - when deleting the box2d world you should also pass NULL to this method
    [[GHDirector sharedDirector] setPhysicalWorld:world];
    
    //set your custom PTM_RATIO
    [[GHDirector sharedDirector] setPointToMeterRatio:PTM_RATIO];


    GHSprite* blueRobot1 = [GHSprite spriteWithSpriteFrameName:@"blueRobot"];
    [blueRobot1 setPosition:ccp(100,100)];
    [batchNodeParent addChild:blueRobot1];
    
    GHSprite* blueRobot2 = [GHSprite spriteWithSpriteFrameName:@"blueRobot"];
    [blueRobot2 setPosition:ccp(200,100)];
    [batchNodeParent addChild:blueRobot2];

    
    GHSprite* pinkRobot1 = [GHSprite spriteWithSpriteFrameName:@"pinkRobot"];
    [pinkRobot1 setPosition:ccp(100,200)];
    [batchNodeParent addChild:pinkRobot1];
    
    GHSprite* pinkRobot2 = [GHSprite spriteWithSpriteFrameName:@"pinkRobot"];
    [pinkRobot2 setPosition:ccp(200,200)];
    [batchNodeParent addChild:pinkRobot2];

    
    GHSprite* greenRobot1 = [GHSprite spriteWithSpriteFrameName:@"greenRobot"];
    [greenRobot1 setPosition:ccp(100,300)];
    [batchNodeParent addChild:greenRobot1];
    
    GHSprite* greenRobot2 = [GHSprite spriteWithSpriteFrameName:@"greenRobot"];
    [greenRobot2 setPosition:ccp(200,300)];
    [batchNodeParent addChild:greenRobot2];

    
    return @"\n\n\n\n\nCollision Filtering...\nDrag robots around the screen to test.\nBLUE robots collide with GREEN and PINK\nbut not with BLUE.\nGREEN robots collide with BLUE and PINK\nbut not with GREEN.\nPINK robots collide with all robots.";
}

#ifdef __CC_PLATFORM_IOS

- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    
    //Add a new body/atlas sprite at the touched location
	for( UITouch *touch in touches ) {
		CGPoint location = [touch locationInView: [touch view]];
        
		location = [[CCDirector sharedDirector] convertToGL: location];
        
        [self createMouseJointForTouchLocation:location];
	}
}

- (void)ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{
    
    //Add a new body/atlas sprite at the touched location
	for( UITouch *touch in touches ) {
		CGPoint location = [touch locationInView: [touch view]];
        
		location = [[CCDirector sharedDirector] convertToGL: location];
    
        [self setTargetOnMouseJoint:location];
	}
}

- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
	//Add a new body/atlas sprite at the touched location
	for( UITouch *touch in touches ) {
		CGPoint location = [touch locationInView: [touch view]];
        
		location = [[CCDirector sharedDirector] convertToGL: location];
        
        [self destroyMouseJoint];
	}
}

-(void)ccTouchCancelled:(UITouch *)touch withEvent:(UIEvent *)event{
    [self destroyMouseJoint];
}

#endif

-(void)dealloc{
    
    [[GHDirector sharedDirector] setPhysicalWorld:NULL];
    
    delete world;
    world = NULL;
    
    [super dealloc];
}
@end













////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#pragma mark - AppDelegate

#ifdef __CC_PLATFORM_IOS

@implementation AppController

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSMutableDictionary* options = nil;
    if(launchOptions == nil){
        options = [NSMutableDictionary dictionary];
    }
    else{
        options = [NSMutableDictionary dictionaryWithDictionary:launchOptions];
    }
    [options setObject:[NSNumber numberWithBool:NO] forKey:@"GH_SET_AS_PORTRAIT"];
    
    
    
    
	[super application:application didFinishLaunchingWithOptions:options];
    
	// Turn on display FPS
	[director_ setDisplayStats:YES];
    
	// Turn on multiple touches
	[director_.view setMultipleTouchEnabled:YES];
    
	// 2D projection
	[director_ setProjection:kCCDirectorProjection2D];
    //	[director_ setProjection:kCCDirectorProjection3D];
    
	// Enables High Res mode (Retina Display) on iPhone 4 and maintains low res on all other devices
	if( ! [director_ enableRetinaDisplay:YES] )
		CCLOG(@"Retina Display Not supported");
    
    
	// Default texture format for PNG/BMP/TIFF/JPEG/GIF images
	// It can be RGBA8888, RGBA4444, RGB5_A1, RGB565
	// You can change anytime.
	[CCTexture2D setDefaultAlphaPixelFormat:kCCTexture2DPixelFormat_RGBA8888];
    
	// Assume that PVR images have the alpha channel premultiplied
	[CCTexture2D PVRImagesHavePremultipliedAlpha:YES];
    
	// If the 1st suffix is not found, then the fallback suffixes are going to used. If none is found, it will try with the name without suffix.
	// On iPad HD  : "-ipadhd", "-ipad",  "-hd"
	// On iPad     : "-ipad", "-hd"
	// On iPhone HD: "-hd"
	CCFileUtils *sharedFileUtils = [CCFileUtils sharedFileUtils];
	[sharedFileUtils setEnableFallbackSuffixes:YES];			// Default: NO. No fallback suffixes are going to be used
	[sharedFileUtils setiPhoneRetinaDisplaySuffix:@"-hd"];		// Default on iPhone RetinaDisplay is "-hd"
	[sharedFileUtils setiPadSuffix:@"-ipad"];					// Default on iPad is "ipad"
	[sharedFileUtils setiPadRetinaDisplaySuffix:@"-ipadhd"];	// Default on iPad RetinaDisplay is "-ipadhd"
    
	// add layer
	CCScene *scene = [CCScene node];
	id layer = [TEST_CLASS node];
	[scene addChild:layer z:0];
    
	[director_ pushScene: scene];
    
	return YES;
}

@end

#elif defined(__CC_PLATFORM_MAC)

#pragma mark AppController - Mac

@implementation AppController

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
	[super applicationDidFinishLaunching:aNotification];
    
	// add layer
	CCScene *scene = [CCScene node];
	[scene addChild: [TEST_CLASS node] ];
    
	[director_ runWithScene:scene];
}
@end
#endif

