
#import "Skeleton_Vs_SpriteSheetAnimation_Test.h"


@implementation Skeleton_Vs_SpriteSheetAnimation_Test


-(NSString*)initTest
{
    CGSize s = [CCDirector sharedDirector].winSize;
    
    [self executeTestCodeAtPosition:ccp(s.width/2, s.height/2-60)];

    glClearColor(0.5, 0.5, 0.5, 1);//white background


    return @"\n\nSkeletal vs sprite sheet animation memory usage.\nPlease read comments in\nSkeleton_Vs_SpriteSheetAnimation_Test.mm file line 20";
    
    
    /*
     HOW TO TEST
     
     The following test needs to be run on the device. Once you plug in the device select it and then go to Product -> Profile
     
     In the new window select "Activity Monitor" and then click "Profile" button.
     Click on "Real Memory Usage" 
     Find "SkeletonVsSprite" in the "Process Name"
     You will see the real memory usage in the "Real Mem" column

     Make sure you set the variable "useSpriteSheet" to YES or NO to test using skeleton animation or sprite sheet animation.

     
     Test results:
     Using SPRITE SHEET ANIMATION
     on iphone 4S - retina enabled
     
     Loading an image of 2048x2031 - 2.8MB
     Real memory usage - 22.19MB
     Virtual memory usage - 170.15MB
     
     
     
     Using SKELETAL ANIMATION
     on iphone 4S - retina enabled
     Loading an image of 130x756 - 114KB
     Real memory usage - 7.11MB
     Virtual memory usage - 154.62MB
     
     
     
     Understanding this test results:
     In a real world usage you will need more then 1 animation.

     So when using sprite sheets animations with each animation you will load many more images - making the texture memory usage bigger with every animation.
     
     Using skeletal animations you will only load 1 image - so the memory usage will remain relatively the same no mather how many animations you have.

     In this example the sprite sheet animation was exported with a 24 frames per second, while the skeletal animation runs with 60 frames per second.
     
     */
}

-(void)executeTestCodeAtPosition:(CGPoint)p
{
    
    //set NO for using SKELETAL ANIMATION
    //set YES for using SPRITE SHEET ANIMATION
    BOOL useSpriteSheet = YES;
    
    if(useSpriteSheet == false)
    {
        //USING SKELETAL ANIMATION
        
        GHSkeletalAnimationCache* cache = [GHSkeletalAnimationCache sharedSkeletalAnimationCache];
        [cache addSkeletalAnimationWithFile:@"RES_Skeletons_LoadTest/skeletons/animations/Death.plist"];
        
        GHSkeleton* skeleton = [GHSkeleton skeletonWithFile:@"RES_Skeletons_LoadTest/skeletons/Officer_Officer.plist"];
        
        [skeleton setPosition:p];
        
        [self addChild:skeleton];
        
        [skeleton playAnimationWithName:@"Death"];
//        [[skeleton animation] setPlayMode:GH_SKELETAL_ANIM_PLAY_LOOP];
    }
    
    else{
        //USING SPRITE SHEET ANIMATION
        
        
        // Use batch node. Faster
        //when using batches - load a batch node using the generated image
		batchNodeParent = [CCSpriteBatchNode batchNodeWithFile:@"RES_Skeleton_VS_SpriteSheetAnimaton/DeathAnimScene_DeathAnim.png" capacity:100];
		[self addChild:batchNodeParent z:0];

        //load into the sprite frame cache the plist generated by SH
        [[CCSpriteFrameCache sharedSpriteFrameCache] addSpriteFramesWithFile:@"RES_Skeleton_VS_SpriteSheetAnimaton/DeathAnimScene_DeathAnim.plist"];

        
        NSMutableArray* frames = [NSMutableArray array];
        
        for(int i = 0; i < 77; ++i)
        {
            NSString* frameName = [NSString stringWithFormat:@"Death_%d.png", i];
            CCSpriteFrame *frm = [[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:frameName];
            [frames addObject:frm];
        }
        
        CCAnimation *anim = [CCAnimation  animationWithSpriteFrames:frames
                                                              delay:1.0f/24.0f];
        
        CCAnimate *animAction = [CCAnimate actionWithAnimation:anim];
        
        GHSprite * newSpr = [GHSprite spriteWithSpriteFrameName:@"Death_0.png"];
        
        [batchNodeParent addChild:newSpr];
        
        [newSpr setPosition:p];
        
        [newSpr runAction:animAction];
    }
    
    

}

-(void)dealloc{
    
    [[CCTextureCache sharedTextureCache] removeUnusedTextures];
    [super dealloc];
}


- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
	//Add a new body/atlas sprite at the touched location
	for( UITouch *touch in touches ) {
		CGPoint location = [touch locationInView: [touch view]];
        
		location = [[CCDirector sharedDirector] convertToGL: location];

        [[CCDirector sharedDirector] replaceScene:[Skeleton_Vs_SpriteSheetAnimation_Test scene]];
	}
}

+(CCScene*)scene
{
    CCScene *scene = [CCScene node];
	[scene addChild: [TEST_CLASS node] ];
    return scene;
}

@end




////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


#pragma mark - AppDelegate

#ifdef __CC_PLATFORM_IOS

@implementation AppController

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
	[super application:application didFinishLaunchingWithOptions:launchOptions];

	// Turn on display FPS
	[director_ setDisplayStats:YES];

	// Turn on multiple touches
	[director_.view setMultipleTouchEnabled:YES];

	// 2D projection
	[director_ setProjection:kCCDirectorProjection2D];
//	[director_ setProjection:kCCDirectorProjection3D];

	// Enables High Res mode (Retina Display) on iPhone 4 and maintains low res on all other devices
	if( ! [director_ enableRetinaDisplay:YES] )
		CCLOG(@"Retina Display Not supported");

    
	// Default texture format for PNG/BMP/TIFF/JPEG/GIF images
	// It can be RGBA8888, RGBA4444, RGB5_A1, RGB565
	// You can change anytime.
	[CCTexture2D setDefaultAlphaPixelFormat:kCCTexture2DPixelFormat_RGBA8888];

	// Assume that PVR images have the alpha channel premultiplied
	[CCTexture2D PVRImagesHavePremultipliedAlpha:YES];

	// If the 1st suffix is not found, then the fallback suffixes are going to used. If none is found, it will try with the name without suffix.
	// On iPad HD  : "-ipadhd", "-ipad",  "-hd"
	// On iPad     : "-ipad", "-hd"
	// On iPhone HD: "-hd"
	CCFileUtils *sharedFileUtils = [CCFileUtils sharedFileUtils];
	[sharedFileUtils setEnableFallbackSuffixes:YES];			// Default: NO. No fallback suffixes are going to be used
	[sharedFileUtils setiPhoneRetinaDisplaySuffix:@"-hd"];		// Default on iPhone RetinaDisplay is "-hd"
	[sharedFileUtils setiPadSuffix:@"-ipad"];					// Default on iPad is "ipad"
	[sharedFileUtils setiPadRetinaDisplaySuffix:@"-ipadhd"];	// Default on iPad RetinaDisplay is "-ipadhd"

	// add layer
	CCScene *scene = [CCScene node];
	id layer = [TEST_CLASS node];
	[scene addChild:layer z:0];

	[director_ pushScene: scene];

	return YES;
}
     
@end

#elif defined(__CC_PLATFORM_MAC)

#pragma mark AppController - Mac

@implementation AppController

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{
	[super applicationDidFinishLaunching:aNotification];

	// add layer
	CCScene *scene = [CCScene node];
	[scene addChild: [TEST_CLASS node] ];

	[director_ runWithScene:scene];
}
@end
#endif
